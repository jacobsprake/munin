import { NextRequest, NextResponse } from 'next/server';
import { readFile, readdir } from 'fs/promises';
import { join } from 'path';

/**
 * GET /api/shadow/report
 * 
 * Get shadow mode report with pagination, filters, and summary stats.
 * Supports query parameters:
 * - page: Page number (default: 1)
 * - limit: Items per page (default: 20)
 * - incident_id: Filter by incident ID
 * - start_date: Filter by start date (ISO string)
 * - end_date: Filter by end date (ISO string)
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const incidentId = searchParams.get('incident_id');
    const startDate = searchParams.get('start_date');
    const endDate = searchParams.get('end_date');
    
    // Load shadow mode report (would be generated by Python engine)
    const engineOutDir = join(process.cwd(), 'engine', 'out');
    const reportPath = join(engineOutDir, 'shadow_report.json');
    
    let reportData: any = {
      shadow_mode_status: 'active',
      shadow_mode_start: new Date().toISOString(),
      shadow_mode_end: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
      summary: {
        total_incidents_observed: 0,
        total_human_actions: 0,
        total_munin_predictions: 0,
        total_time_saved_seconds: 0,
        total_damage_prevented_estimate: 0,
        average_improvement_ratio: 0
      },
      top_improvements: [],
      comparisons: []
    };
    
    try {
      const reportContent = await readFile(reportPath, 'utf-8');
      reportData = JSON.parse(reportContent);
    } catch (error) {
      // Report not generated yet, return default structure
      console.log('Shadow report not found, returning default structure');
    }
    
    // Load comparisons from shadow_actions.jsonl if available
    const actionsPath = join(engineOutDir, 'shadow_actions.jsonl');
    let comparisons: any[] = [];
    
    try {
      const actionsContent = await readFile(actionsPath, 'utf-8');
      const lines = actionsContent.split('\n').filter(line => line.trim());
      comparisons = lines.map(line => JSON.parse(line))
        .filter(entry => entry.action_type === 'comparison');
    } catch (error) {
      // Actions file not found
    }
    
    // Apply filters
    if (incidentId) {
      comparisons = comparisons.filter(c => c.incident_id === incidentId);
    }
    
    if (startDate) {
      const start = new Date(startDate);
      comparisons = comparisons.filter(c => new Date(c.timestamp) >= start);
    }
    
    if (endDate) {
      const end = new Date(endDate);
      comparisons = comparisons.filter(c => new Date(c.timestamp) <= end);
    }
    
    // Paginate
    const startIdx = (page - 1) * limit;
    const endIdx = startIdx + limit;
    const paginatedComparisons = comparisons.slice(startIdx, endIdx);
    
    // Calculate summary stats
    const totalTimeSaved = comparisons.reduce((sum, c) => 
      sum + (c.comparison?.time_saved_seconds || 0), 0
    );
    const totalDamagePrevented = comparisons.reduce((sum, c) => 
      sum + (c.comparison?.damage_prevented_estimate || 0), 0
    );
    const avgImprovement = comparisons.length > 0
      ? comparisons.reduce((sum, c) => sum + (c.comparison?.improvement_ratio || 0), 0) / comparisons.length
      : 0;
    
    return NextResponse.json({
      shadow_mode_status: reportData.shadow_mode_status,
      shadow_mode_start: reportData.shadow_mode_start,
      shadow_mode_end: reportData.shadow_mode_end,
      summary: {
        total_incidents_observed: comparisons.length,
        total_human_actions: reportData.summary.total_human_actions,
        total_munin_predictions: reportData.summary.total_munin_predictions,
        total_time_saved_seconds: totalTimeSaved,
        total_damage_prevented_estimate: totalDamagePrevented,
        average_improvement_ratio: avgImprovement
      },
      top_improvements: reportData.top_improvements || [],
      comparisons: paginatedComparisons,
      pagination: {
        page,
        limit,
        total: comparisons.length,
        total_pages: Math.ceil(comparisons.length / limit)
      }
    });
  } catch (error: any) {
    console.error('Error loading shadow report:', error);
    return NextResponse.json(
      { error: 'Failed to load shadow report', details: error.message },
      { status: 500 }
    );
  }
}
